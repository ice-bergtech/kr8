package cmd

import (
	"fmt"
	"strings"

	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/tidwall/gjson"
)

// init a struct for a single item
type Cluster struct {
	Name string
	Path string
}

// init a grouping struct
type Clusters struct {
	Cluster []Cluster
}

type ClusterSpec struct {
	PostProcessor string `json:"postprocessor"`
	GenerateDir   string `json:"generate_dir"`
	// if this is true, we don't use the full file path to generate output file names
	GenerateShortNames bool `json:"generate_short_names"`
	// if this is true, we prune component parameters
	PruneParams bool `json:"prune_params"`
	ClusterDir  string
}

func CreateClusterSpec(cmd *cobra.Command, clusterName string, spec gjson.Result) (ClusterSpec, error) {
	// First determine the value of generate_dir from the command line args or spec.
	clGenerateDir := cmd.Flags().Lookup("generate-dir").Value.String()
	if clGenerateDir == "" {
		clGenerateDir = spec.Get("generate_dir").String()
	}
	if clGenerateDir == "" {
		return ClusterSpec{}, fmt.Errorf("_kr8_spec.generate_dir must be set in parameters or passed as generate-dir flag")
	}
	// if generateDir does not start with /, then it goes in baseDir
	if !strings.HasPrefix(clGenerateDir, "/") {
		clGenerateDir = baseDir + "/" + clGenerateDir
	}
	clusterDir := clGenerateDir + "/" + clusterName
	return ClusterSpec{
		spec.Get("postprocessor").String(),
		clGenerateDir,
		// if this is true, we don't use the full file path to generate output file names
		spec.Get("generate_short_names").Bool(),
		spec.Get("prune_params").Bool(),
		clusterDir,
	}, nil
}

// kr8_spec object in cluster config
type ComponentSpec struct {
	Kr8_allparams   bool `json:"enable_kr8_allparams"`
	Kr8_allclusters bool `json:"enable_kr8_allclusters"`
	// If false, output directory files will be removed unless they were generated by kr8
	DisableOutputDirClean bool `json:"disable_output_clean"`
	// list of filenames to include as jsonnet vm external vars
	ExtFiles []ExtFileVar `json:"extfiles"`
	// additional jsonnet libs to include, component scoped
	JPaths []string `json:"jpaths"`
	// list of filenames to include and output as files 1-1
	Includes []string `json:"includes"`
}

func CreateComponentSpec(spec gjson.Result) (ComponentSpec, error) {
	specM := spec.Map()
	// spec is missing?
	if len(specM) == 0 {
		log.Fatal().Str("component", componentName).
			Msg("Component has no `kr8_spec` object")
	}

	return ComponentSpec{
		Kr8_allparams:         spec.Get("enable_kr8_allparams").Bool(),
		Kr8_allclusters:       spec.Get("enable_kr8_allclusters").Bool(),
		DisableOutputDirClean: spec.Get("disable_output_clean").Bool(),
		// ExtFiles:              spec.Get("extfiles").Array().StringSlice(),
		// JPaths:                spec.Get("jpaths").Array().StringSlice(),
		// Includes:              spec.Get("includes").Array().StringSlice(),
	}, nil
}

// file to load as a string into the jsonnet vm
type ExtFileVar struct {
	// name to reference the variable in jsonnet code through std.extvar()
	Name string
	// value of the variable, loaded from a file or provided directly
	Value string
}

// A struct describing an included file
type IncludeFileSpec interface {
	string
	struct {
		// an input file to process
		// accepted filetypes: .jsonnet .yml .yaml .tmpl .tpl
		File string `json:"file"`
		// handle alternate output directory for file
		DestDir string `json:"dest_dir"`
		// override destination file name
		DestName string `json:"dest_name"`
		// override destination file extension
		DestExt string `json:"dest_ext"`
	}
}
